<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Playing with Claude Code to build an Agentic Platform | Visage of Vee</title>
<meta name=keywords content><meta name=description content="So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go."><meta name=author content><link rel=canonical href=veesage.github.io/articles/test-mermaid/><link crossorigin=anonymous href=/veesage.github.io/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/veesage.github.io/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=veesage.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=veesage.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=veesage.github.io/favicon-32x32.png><link rel=apple-touch-icon href=veesage.github.io/apple-touch-icon.png><link rel=mask-icon href=veesage.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Playing with Claude Code to build an Agentic Platform"><meta property="og:description" content="So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go."><meta property="og:type" content="article"><meta property="og:url" content="veesage.github.io/articles/test-mermaid/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2025-05-18T20:36:05-07:00"><meta property="article:modified_time" content="2025-05-18T20:36:05-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Playing with Claude Code to build an Agentic Platform"><meta name=twitter:description content="So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"veesage.github.io/articles/"},{"@type":"ListItem","position":3,"name":"Playing with Claude Code to build an Agentic Platform","item":"veesage.github.io/articles/test-mermaid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with Claude Code to build an Agentic Platform","name":"Playing with Claude Code to build an Agentic Platform","description":"So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go.","keywords":[],"articleBody":"So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go.\nI was intrigued by the feasibility of building an agentic platform—a basic Chat UI where you can select an agent and start chatting. You can create your own agent by passing a prompt and a list of skills.\nWith a bit of help from Claude Chat, I was able to design a simple architecture for the platform.\ngraph TD ClientApp[Client App] APILayer[Simple API Layer] AgentLifecycle[Agent Lifecycle Service] AgentService[Agent Service] SkillService[Skill Service] Redis[Redis Storage] ClientApp --\u003e APILayer APILayer --\u003e AgentLifecycle APILayer --\u003e AgentService APILayer --\u003e SkillService AgentLifecycle --\u003e AgentService AgentService --\u003e SkillService SkillService --\u003e Redis After setting up the Claude Code CLI on my local machine, I was able to prompt it to build a scaffolding of the platform while referencing the CLAUDE.md file in the repository. To my surprise—and at the cost of an additional $10 worth of prompting—it was able to generate a working API-based application, triggering the skills.\nFor web search and LLM functionalities, I did some cross-referencing and ultimately chose SerpAPI for web search and Groq for LLM and related skills and they have generous free tiers.\nDuring prompting, I made sure to specify the use of LangGraph for the Agent Service. Furthermore, from an operational simplicity perspective, I asked it to Dockerize the entire service in one repository. This will be useful later.\n:bulb: Tips to operate with Claude Code\nFamiliarize yourself with https://www.anthropic.com/engineering/claude-code-best-practices Use the –verbose flag to get more details about the prompt To reduce your token usage, ensure you don’t ask it to generate tests or write comments or verbose documentation. This will save you some credits but at the cost of figuring out the code Develop the system iteratively and prompt by prompt e.g Initialize Your Project Structure Implement Shared Components Setup Redis Integration Implement the Skill Service Implement the Agent Lifecycle Service Implement the Agent Service Implement the API Service Create Main Application Entry Point Add a README Test the application Here’s the CLAUDE.md file I used to generate the scaffolding.\n# CLAUDE.md - Agentic Platform MVP Development Guide ## Project Overview This project is an MVP for an agentic platform with the following core components: 1. Agent Lifecycle Service 2. Agent Service 3. Skill Service 4. Redis for experiential memory 5. Simple API layer for user interactions ## Development Standards ### Technology Stack - Python 3.11+ - LangGraph for agent workflow orchestration - FastAPI for API endpoints - Redis for memory storage and state management - LangChain for some skill integrations ### Coding Standards - Use type hints throughout the codebase - Create modular components - Follow PEP 8 conventions - Use async/await pattern where appropriate for API endpoints ### Project Structure ``` agentic-platform/ ├── services/ │ ├── agent_lifecycle/ │ ├── agent_service/ │ ├── skill_service/ │ └── api/ ├── shared/ │ ├── models/ │ ├── utils/ │ └── config/ ├── docker-compose.yml ├── requirements.txt └── README.md ``` ## Implementation Details ### Core Service Models #### Agent Model ```python class Agent: agent_id: str # Unique identifier name: str # Human-readable name description: str # Purpose description status: str # \"active\", \"inactive\", etc. skills: List[str] # Skill IDs the agent can use config: Dict[str, Any] # Configuration parameters ``` #### Skill Model ```python class Skill: skill_id: str # Unique identifier name: str # Human-readable name description: str # What the skill does parameters: List[Dict] # Required and optional parameters response_format: Dict # Expected response structure ``` #### Conversation Model ```python class Message: id: str role: str # \"user\" or \"agent\" content: str timestamp: datetime metadata: Dict[str, Any] # Optional metadata class Conversation: id: str agent_id: str user_id: str messages: List[Message] status: str # \"active\", \"completed\", etc. created_at: datetime updated_at: datetime metadata: Dict[str, Any] # Optional metadata ``` ### LangGraph Implementation Use LangGraph for implementing agent workflows. LangGraph helps create structured, stateful agent workflows, particularly suitable for this MVP. Specifically: 1. Define agent state and transitions 2. Create nodes for different agent operations (reasoning, skill execution, etc.) 3. Define the graph structure connecting these nodes 4. Handle conversation context and memory integration ## Service Implementation Guidelines ### 1. Agent Lifecycle Service Create a service that manages agent registration and status. Implement: - Agent creation/registration - Status management (activate/deactivate) - Configuration storage in Redis - Simple validation for agent configuration Use FastAPI for the REST endpoints and Redis for storage. Keep interfaces minimal but sufficient to demonstrate core functionality. ### 2. Agent Service Implement the core agent runtime with LangGraph. Create: - A reasoning node that determines actions based on user input - A skill execution node that calls the Skill Service - A response formulation node that creates user-facing messages - State management that tracks conversation context Focus on a simple but effective reasoning approach for MVP - don't overengineer the cognitive architecture. ### 3. Skill Service Create a simple skill registry and execution service: - Implement basic skill registration - Create skill validation logic - Develop execution framework - Implement three core skills: - web-search: Use a simple wrapper around a search API using SerpAPI using the following API private key MY_API_KEY - summarize-text: Use Claude - ask-follow-up: Generate follow-up questions based on context ### 4. Redis Integration Use Redis for all stateful data: - Agent configurations - Active conversations - Working memory for agents - Skill execution results Define clear Redis key structures and data formats. Use Redis data types appropriately (Hashes, Lists, Sets, etc.). ### 5. API Layer Create a simple but complete API layer with FastAPI: - User authentication (simplified for MVP) - Conversation management - Message sending/receiving - Agent status queries ## Implementation Sequence 1. Set up the project structure and shared components 2. Implement Redis integration and basic data models 3. Create the Skill Service with 2-3 example skills 4. Develop the Agent Service with LangGraph workflows 5. Implement the Agent Lifecycle service 6. Create the API layer 7. Build a simple frontend (optional for MVP) ## Development Tips 1. Use a local Redis instance for development 2. Create small, focused services that communicate via well-defined APIs 3. Use environment variables for configuration 4. Log agent actions and skill executions for debugging 5. Implement proper error handling from the beginning ## LangGraph-Specific Guidance When implementing the agent workflow with LangGraph: 1. Use the `StateGraph` class to create the agent's state machine 2. Define clear states like \"receiving_input\", \"reasoning\", \"executing_skill\", \"formulating_response\" 3. Create typed state classes to maintain type safety 4. Implement conditional edges for dynamic agent behavior 5. Use the async API for better performance 6. Leverage LangGraph's memory interfaces for maintaining context Example LangGraph structure: ```python from langgraph.graph import StateGraph from pydantic import BaseModel, Field # Define state class AgentState(BaseModel): messages: List[Message] = Field(default_factory=list) context: Dict[str, Any] = Field(default_factory=dict) current_skill: Optional[str] = None skill_results: List[Dict] = Field(default_factory=list) # Create nodes def reasoning(state: AgentState) -\u003e AgentState: # Determine next actions # ... return updated_state def execute_skill(state: AgentState) -\u003e AgentState: # Call skill service # ... return updated_state def formulate_response(state: AgentState) -\u003e AgentState: # Create response for user # ... return updated_state # Build graph graph = StateGraph(AgentState) graph.add_node(\"reasoning\", reasoning) graph.add_node(\"execute_skill\", execute_skill) graph.add_node(\"formulate_response\", formulate_response) # Add edges graph.add_edge(\"reasoning\", \"execute_skill\") graph.add_edge(\"execute_skill\", \"formulate_response\") graph.add_edge(\"formulate_response\", \"reasoning\") # Conditional branching def should_execute_skill(state: AgentState) -\u003e str: if state.current_skill: return \"execute_skill\" return \"formulate_response\" graph.add_conditional_edges(\"reasoning\", should_execute_skill, {\"execute_skill\": \"execute_skill\", \"formulate_response\": \"formulate_response\"}) # Compile the graph agent_executor = graph.compile() ``` ## Testing For the MVP, no unit tests or other tests are required to reduce token consumption ## Deployment For the MVP, a simple local deployment is sufficient. ## Documentation For the MVP, No need to document in detail, keep is simple to reduce token consumption. ","wordCount":"1339","inLanguage":"en","datePublished":"2025-05-18T20:36:05-07:00","dateModified":"2025-05-18T20:36:05-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"veesage.github.io/articles/test-mermaid/"},"publisher":{"@type":"Organization","name":"Visage of Vee","logo":{"@type":"ImageObject","url":"veesage.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=veesage.github.io accesskey=h title="Visage of Vee (Alt + H)">Visage of Vee</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=veesage.github.io/veesage.github.io/ title=Articles><span>Articles</span></a></li><li><a href=veesage.github.io/veesage.github.io/notes title=Notes><span>Notes</span></a></li><li><a href=veesage.github.io/veesage.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Playing with Claude Code to build an Agentic Platform</h1><div class=post-meta><span title='2025-05-18 20:36:05 -0700 PDT'>May 18, 2025</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><p>So, it was Sunday night, and after putting our toddler to sleep, I was finally able to sit down and experiment with Claude Code to build an Agentic Platform. I’ve been a long-time lurker on Hacker News and had heard great things about Claude Code, so I just had to try it. As a big Claude user, I signed up for Claude Code in the Developer Console, set up my credit card with $20 in credits, and was ready to go.</p><p>I was intrigued by the feasibility of building an agentic platform—a basic Chat UI where you can select an agent and start chatting. You can create your own agent by passing a prompt and a list of skills.</p><p>With a bit of help from Claude Chat, I was able to design a simple architecture for the platform.</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script><div class=mermaid>graph TD
ClientApp[Client App]
APILayer[Simple API Layer]
AgentLifecycle[Agent Lifecycle Service]
AgentService[Agent Service]
SkillService[Skill Service]
Redis[Redis Storage]
ClientApp --> APILayer
APILayer --> AgentLifecycle
APILayer --> AgentService
APILayer --> SkillService
AgentLifecycle --> AgentService
AgentService --> SkillService
SkillService --> Redis</div><p>After setting up the Claude Code CLI on my local machine, I was able to prompt it to build a scaffolding of the platform while referencing the CLAUDE.md file in the repository. To my surprise—and at the cost of an additional $10 worth of prompting—it was able to generate a working API-based application, triggering the skills.</p><p>For web search and LLM functionalities, I did some cross-referencing and ultimately chose SerpAPI for web search and Groq for LLM and related skills and they have generous free tiers.</p><p>During prompting, I made sure to specify the use of LangGraph for the Agent Service. Furthermore, from an operational simplicity perspective, I asked it to Dockerize the entire service in one repository. This will be useful later.</p><p>:bulb: Tips to operate with Claude Code</p><ol><li>Familiarize yourself with <a href=https://www.anthropic.com/engineering/claude-code-best-practices>https://www.anthropic.com/engineering/claude-code-best-practices</a></li><li>Use the &ndash;verbose flag to get more details about the prompt</li><li>To reduce your token usage, ensure you don&rsquo;t ask it to generate tests or write comments or verbose documentation. This will save you some credits but at the cost of figuring out the code</li><li>Develop the system iteratively and prompt by prompt e.g<ol><li>Initialize Your Project Structure</li><li>Implement Shared Components</li><li>Setup Redis Integration</li><li>Implement the Skill Service</li><li>Implement the Agent Lifecycle Service</li><li>Implement the Agent Service</li><li>Implement the API Service</li><li>Create Main Application Entry Point</li><li>Add a README</li><li>Test the application</li></ol></li></ol><p>Here’s the CLAUDE.md file I used to generate the scaffolding.</p><pre><code class=language-markdown># CLAUDE.md - Agentic Platform MVP Development Guide

## Project Overview

This project is an MVP for an agentic platform with the following core components:
1. Agent Lifecycle Service
2. Agent Service
3. Skill Service
4. Redis for experiential memory
5. Simple API layer for user interactions

## Development Standards

### Technology Stack
- Python 3.11+
- LangGraph for agent workflow orchestration
- FastAPI for API endpoints
- Redis for memory storage and state management
- LangChain for some skill integrations

### Coding Standards
- Use type hints throughout the codebase
- Create modular components
- Follow PEP 8 conventions
- Use async/await pattern where appropriate for API endpoints

### Project Structure
```
agentic-platform/
├── services/
│   ├── agent_lifecycle/
│   ├── agent_service/
│   ├── skill_service/
│   └── api/
├── shared/
│   ├── models/
│   ├── utils/
│   └── config/
├── docker-compose.yml
├── requirements.txt
└── README.md
```

## Implementation Details

### Core Service Models

#### Agent Model
```python
class Agent:
    agent_id: str  # Unique identifier
    name: str  # Human-readable name
    description: str  # Purpose description
    status: str  # "active", "inactive", etc.
    skills: List[str]  # Skill IDs the agent can use
    config: Dict[str, Any]  # Configuration parameters
```

#### Skill Model
```python
class Skill:
    skill_id: str  # Unique identifier
    name: str  # Human-readable name
    description: str  # What the skill does
    parameters: List[Dict]  # Required and optional parameters
    response_format: Dict  # Expected response structure
```

#### Conversation Model
```python
class Message:
    id: str
    role: str  # "user" or "agent"
    content: str
    timestamp: datetime
    metadata: Dict[str, Any]  # Optional metadata

class Conversation:
    id: str
    agent_id: str
    user_id: str
    messages: List[Message]
    status: str  # "active", "completed", etc.
    created_at: datetime
    updated_at: datetime
    metadata: Dict[str, Any]  # Optional metadata
```

### LangGraph Implementation

Use LangGraph for implementing agent workflows. LangGraph helps create structured, stateful agent workflows, particularly suitable for this MVP. Specifically:

1. Define agent state and transitions
2. Create nodes for different agent operations (reasoning, skill execution, etc.)
3. Define the graph structure connecting these nodes
4. Handle conversation context and memory integration

## Service Implementation Guidelines

### 1. Agent Lifecycle Service

Create a service that manages agent registration and status. Implement:

- Agent creation/registration
- Status management (activate/deactivate)
- Configuration storage in Redis
- Simple validation for agent configuration

Use FastAPI for the REST endpoints and Redis for storage. Keep interfaces minimal but sufficient to demonstrate core functionality.

### 2. Agent Service

Implement the core agent runtime with LangGraph. Create:

- A reasoning node that determines actions based on user input
- A skill execution node that calls the Skill Service
- A response formulation node that creates user-facing messages
- State management that tracks conversation context

Focus on a simple but effective reasoning approach for MVP - don't overengineer the cognitive architecture.

### 3. Skill Service

Create a simple skill registry and execution service:

- Implement basic skill registration
- Create skill validation logic
- Develop execution framework
- Implement three core skills:
  - web-search: Use a simple wrapper around a search API using SerpAPI using the following API private key MY_API_KEY
  - summarize-text: Use Claude
  - ask-follow-up: Generate follow-up questions based on context

### 4. Redis Integration

Use Redis for all stateful data:

- Agent configurations
- Active conversations
- Working memory for agents
- Skill execution results

Define clear Redis key structures and data formats. Use Redis data types appropriately (Hashes, Lists, Sets, etc.).

### 5. API Layer

Create a simple but complete API layer with FastAPI:

- User authentication (simplified for MVP)
- Conversation management
- Message sending/receiving
- Agent status queries

## Implementation Sequence

1. Set up the project structure and shared components
2. Implement Redis integration and basic data models
3. Create the Skill Service with 2-3 example skills
4. Develop the Agent Service with LangGraph workflows
5. Implement the Agent Lifecycle service
6. Create the API layer
7. Build a simple frontend (optional for MVP)

## Development Tips

1. Use a local Redis instance for development
2. Create small, focused services that communicate via well-defined APIs
3. Use environment variables for configuration
4. Log agent actions and skill executions for debugging
5. Implement proper error handling from the beginning

## LangGraph-Specific Guidance

When implementing the agent workflow with LangGraph:

1. Use the `StateGraph` class to create the agent's state machine
2. Define clear states like "receiving_input", "reasoning", "executing_skill", "formulating_response"
3. Create typed state classes to maintain type safety
4. Implement conditional edges for dynamic agent behavior
5. Use the async API for better performance
6. Leverage LangGraph's memory interfaces for maintaining context

Example LangGraph structure:
```python
from langgraph.graph import StateGraph
from pydantic import BaseModel, Field

# Define state
class AgentState(BaseModel):
    messages: List[Message] = Field(default_factory=list)
    context: Dict[str, Any] = Field(default_factory=dict)
    current_skill: Optional[str] = None
    skill_results: List[Dict] = Field(default_factory=list)
    
# Create nodes
def reasoning(state: AgentState) -> AgentState:
    # Determine next actions
    # ...
    return updated_state

def execute_skill(state: AgentState) -> AgentState:
    # Call skill service
    # ...
    return updated_state

def formulate_response(state: AgentState) -> AgentState:
    # Create response for user
    # ...
    return updated_state

# Build graph
graph = StateGraph(AgentState)
graph.add_node("reasoning", reasoning)
graph.add_node("execute_skill", execute_skill)
graph.add_node("formulate_response", formulate_response)

# Add edges
graph.add_edge("reasoning", "execute_skill")
graph.add_edge("execute_skill", "formulate_response")
graph.add_edge("formulate_response", "reasoning")

# Conditional branching
def should_execute_skill(state: AgentState) -> str:
    if state.current_skill:
        return "execute_skill"
    return "formulate_response"

graph.add_conditional_edges("reasoning", should_execute_skill, 
                           {"execute_skill": "execute_skill", 
                            "formulate_response": "formulate_response"})

# Compile the graph
agent_executor = graph.compile()
```

## Testing

For the MVP, no unit tests or other tests are required to reduce token consumption


## Deployment

For the MVP, a simple local deployment is sufficient. 

## Documentation

For the MVP, No need to document in detail, keep is simple to reduce token consumption.

</code></pre></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=veesage.github.io>Visage of Vee</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>